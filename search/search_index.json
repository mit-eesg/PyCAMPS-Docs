{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyCAMPS","text":"<p>PyCAMPS is a Python library for building, solving, analyzing, and simulating power systems, all with a user-friendly GUI. For more information about our PyPI package, visit our PyPI page.</p> <p>Our package is a Python version of the Centralized Automated Modeling of Power Systems library developed by the MIT Electric Energy Systems Group, led by Professor Marija Ilic. For more information and updates, please visit our website.</p>"},{"location":"#license","title":"License","text":"<p>PyCAMPS is licensed under the MIT license. See LICENSE for details.</p>"},{"location":"api_overview/","title":"API Reference for PyCAMPS","text":""},{"location":"api_overview/#overview","title":"Overview","text":"<p>PyCAMPS consists of several different classes and functions that allow the user to create and analyze power systems. Dynamic components of power systems are implemented in Modules, while the tools to simulate the modules and the overall  system lie in Simulation. For other extra functions, reference Miscellaneous.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#user-installation","title":"User Installation","text":"<p>Here's how you can install PyCAMPS:</p> <pre><code>pip install pycamps\n</code></pre>"},{"location":"installation/#dev-installation","title":"Dev Installation","text":"<p>Here's how you can install PyCAMPS for development:</p> <pre><code>git clone https://github.com/mit-eesg/PyCAMPS.git\ncd PyCAMPS\npython setup.py install\n</code></pre>"},{"location":"misc/","title":"<code>Miscellaneous</code>","text":"<p>Example: <pre><code>    import os\n    os.environ['LOG_LEVEL'] = 'DEBUG'\n    configure_logging(log_to_console=True, log_to_file=True)\n    logger.debug(\"Test\")\n</code></pre></p>"},{"location":"misc/#pycamps.logger.configure_logging","title":"<code>pycamps.logger.configure_logging(logger_name='PyCAMPSLogger', log_file='app.log', log_to_console=True, log_to_file=False)</code>","text":"<p>Configures the logging settings for the application.</p> <p>This function sets up the logging configuration for the application. It allows you to log messages to the console, a file, or both. The log level can be controlled via the <code>LOG_LEVEL</code> environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>logger_name</code> <code>str</code> <p>The name of the logger. Default is 'PyCAMPSLogger'.</p> <code>'PyCAMPSLogger'</code> <code>log_file</code> <code>str</code> <p>The name of the log file. Default is 'app.log'.</p> <code>'app.log'</code> <code>log_to_console</code> <code>bool</code> <p>If True, logs will be printed to the console. Default is True.</p> <code>True</code> <code>log_to_file</code> <code>bool</code> <p>If True, logs will be saved to a file. Default is False.</p> <code>False</code> Environment Variables <p>LOG_LEVEL (str): The log level for the logger. Can be 'DEBUG', 'INFO', 'WARNING', 'ERROR', or 'CRITICAL'.                  Default is 'INFO'.</p> Notes <ul> <li>If both <code>log_to_console</code> and <code>log_to_file</code> are set to False, no logs will be output.</li> <li>The log file will be saved in the user's home directory if <code>log_to_file</code> is True.</li> <li>Existing handlers are cleared before adding new ones to avoid duplicate logs.</li> </ul>"},{"location":"modules/","title":"<code>Modules</code>","text":"<p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import InfBus\n    inf_bus = InfBus('Bus1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import LongLine\n    long_line = LongLine('TL_1_2', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import PQLoad\n    load = PQLoad('L1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import PVSOAControl\n    pv = PVSOAControl('PV1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import SolarPV_v2_SOAControl\n    pv = SolarPV_v2_SOAControl('PV1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import RLLoad\n    load = RLLoad('L1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import ShortLine\n    line = ShortLine('TL_1_2', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import SMOneAxis\n    sm = SMOneAxis('G1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import Type4_1\n    sm = Type4_1('G1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import Type4_1Gc\n    sm = Type4_1Gc('G1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import Type4_2\n    sm = Type4_2('G1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p> <p>Example: <pre><code>    from sympy import symbols\n    from pycamps.modules import Type4_2Ec\n    sm = Type4_2Ec('G1', RefFrameAngle=symbols('phi'), RefFrameSpeed=symbols('dphidt'), BaseSpeed=377)\n</code></pre></p>"},{"location":"modules/#pycamps.modules.Module","title":"<code>pycamps.modules.Module</code>","text":"<p>This module serves as a superclass to all dynamic component modules in the power system. </p> <p>Attributes:</p> Name Type Description <code>ModuleName</code> <code>str</code> <p>The name of the module.</p> <code>RefFrameAngle</code> <code>Symbol</code> <p>The angular position of the DQ reference frame.</p> <code>RefFrameSpeed</code> <code>Symbol</code> <p>The angular speed of the DQ reference frame.</p> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system (inverse of time units).</p> <code>ParameterMap</code> <code>dict</code> <p>A dictionary mapping parameter names to their values or functions.</p> <code>Parameters</code> <code>Matrix</code> <p>A matrix of symbolic parameters for the module (inductances, capacitances, etc).</p> <code>ControllerGains</code> <code>Matrix</code> <p>Gains of controllers.</p> <code>SetPoints</code> <code>Matrix</code> <p>Set points for controllers.</p> <code>StateVariables</code> <code>Matrix</code> <p>A matrix of symbolic state variables for the module.</p> <code>StateSpaceEquations</code> <code>Matrix</code> <p>A matrix of state space equations.</p> <code>StateVariableDerivatives</code> <code>Matrix</code> <p>A matrix of derivatives of state variables.</p> <code>PortInputs</code> <code>Matrix</code> <p>Inputs to the module from other modules.</p> <code>PortStates</code> <code>Matrix</code> <p>States of the module.</p> <code>PortVoltages</code> <code>Matrix</code> <p>Voltages at the ports.</p> <code>PortCurrents</code> <code>Matrix</code> <p>Currents at the ports.</p> <code>PortStates_Time</code> <code>Matrix</code> <p>Time-dependent states of the module.</p> <code>PortStateDerivatives</code> <code>Matrix</code> <p>Derivatives of the port states.</p> <code>PortOutputTypes</code> <code>Matrix</code> <p>Types of outputs from the ports (current or charge).</p> <code>ControllableInputs</code> <code>Matrix</code> <p>Inputs that can be controlled, typically for passivity-based control.</p> <code>InternalInputs</code> <code>Matrix</code> <p>Inputs that are internal to the module.</p> <code>ControlInputEquations</code> <code>Matrix</code> <p>Mathematical equations for controllable inputs.</p> <code>InternalEquations</code> <code>Matrix</code> <p>Internal equations of the module.</p> <code>DesiredStateVariables</code> <code>Matrix</code> <p>Desired state variables for underactuated systems.</p> <code>DesiredStateVariableDerivatives</code> <code>Matrix</code> <p>Derivatives of the desired state variables.</p> <code>DesiredStateSpace</code> <code>Matrix</code> <p>Desired state space representation.</p> <code>SetPointOutputs</code> <code>Matrix</code> <p>Outputs that are sent to another module.</p> <code>SetPointOutputEquations</code> <code>Matrix</code> <p>Equations for set point outputs.</p> <code>GTemp</code> <code>Matrix</code> <p>Temporary matrix for calculations.</p> <code>Units</code> <code>list of str</code> <p>The units of the state variables, which depend on the base speed.</p> <code>Data</code> <code>Matrix</code> <p>Additional data related to the module.</p> <code>StateSpace</code> <code>StateSpace</code> <p>State space representation of the module.</p>"},{"location":"modules/#pycamps.modules.InfBus","title":"<code>pycamps.modules.InfBus</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents an infinite bus with a constant voltage source and series impedance.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.LongLine","title":"<code>pycamps.modules.LongLine</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a long transmission line model with resistance, capacitance, and inductances.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.PQLoad","title":"<code>pycamps.modules.PQLoad</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a PQ load in a power system.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.PVSOAControl","title":"<code>pycamps.modules.PVSOAControl</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a solar PV model with SOA control.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.SolarPV_v2_SOAControl","title":"<code>pycamps.modules.SolarPV_v2_SOAControl</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a solar PV model with SOA control.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.RLLoad","title":"<code>pycamps.modules.RLLoad</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a constant impedance load with resistance and inductance.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.ShortLine","title":"<code>pycamps.modules.ShortLine</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a short transmission line model with series impedance.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.SMOneAxis","title":"<code>pycamps.modules.SMOneAxis</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents the one axis model of synchronous machine.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.Type4_1","title":"<code>pycamps.modules.Type4_1</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a standard Type 4-1 model of a synchronous machine.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.Type4_1Gc","title":"<code>pycamps.modules.Type4_1Gc</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a standard Type 4-1 model of a synchronous machine with governor control.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.Type4_2","title":"<code>pycamps.modules.Type4_2</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a standard Type 4-2 model of a synchronous machine.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"modules/#pycamps.modules.Type4_2Ec","title":"<code>pycamps.modules.Type4_2Ec</code>","text":"<p>               Bases: <code>Module</code></p> <p>Represents a standard Type 4-2 model of a synchronous machine with excitation control.</p> <p>Parameters:</p> Name Type Description Default <code>IndexName</code> <code>str</code> <p>A unique identifier for the module. This is used to create names for parameters and state variables.</p> required <code>RefFrameAngle</code> <code>Optional[Symbol]</code> <p>The angle of the reference frame. Defaults to a symbolic variable 'phi' if not provided.</p> <code>None</code> <code>RefFrameSpeed</code> <code>Optional[Symbol]</code> <p>The speed of the reference frame. Defaults to a symbolic variable 'dphidt' if not provided.</p> <code>None</code> <code>BaseSpeed</code> <code>float</code> <p>The base speed of the system. Defaults to 1. This affects the units of the state variables.</p> <code>1</code> <code>ParamMap</code> <code>Optional[dict]</code> <p>A dictionary mapping parameter names to their values. Keys should be in the format '[ParameterName]_IndexName'.</p> <code>None</code>"},{"location":"simulation/","title":"<code>Simulation Tools</code>","text":"<p>Example: <pre><code>    from pycamps.simulation import PowerSystem\n    from pycamps.modules import ShortLine, SMOneAxis, PQLoad\n    modules = [ShortLine(...), SMOneAxis(...), PQLoad(...)]\n    buses = [[(modules[0], 'L'), (modules[1])], [(modules[0], 'R'), (modules[2])]]\n    ps = PowerSystem(\"MyPowerSystem\", modules, buses)\n    print(ps.StateSpaceEquations)\n</code></pre></p> <p>Example: <pre><code>    from pycamps.simulation import PowerSystem, Dynamics\n    ps = PowerSystem(...)\n    dynamics = Dynamics(ps)\n    print(dynamics.get_required_parameters())\n    dynamics.load_new_params(params_directory='params/')\n    equilibrium = dynamics.solve_equilibrium()\n    time, states = dynamics.simulate_trajectory()\n    sub_pf, states = dynamics.linearized_analysis()\n</code></pre></p> <p>Example: <pre><code>    from pycamps.simulation import StateSpace, PowerSystem\n    ps = PowerSystem(...)\n    ss = StateSpace.from_power_system(ps)\n    ss.print_equations()\n</code></pre></p>"},{"location":"simulation/#pycamps.simulation.PowerSystem","title":"<code>pycamps.simulation.PowerSystem</code>","text":"<p>Represents a power system composed of various modules and buses.</p> <p>Parameters:</p> Name Type Description Default <code>SystemName</code> <code>str</code> <p>A unique identifier for the system. This is used to create names for exported files and logs.</p> required <code>Modules</code> <code>list</code> <p>A list of modules (e.g. generators, loads, transmission lines) that make up the power system.</p> required <code>Buses</code> <code>list</code> <p>A list of buses, where each bus contains a list of modules connected to it.</p> required <p>Attributes:</p> Name Type Description <code>Units</code> <code>list</code> <p>Units for the state variables.</p> <code>StateSpace</code> <code>StateSpace</code> <p>State space representation of the system.</p> <code>KCLEquations</code> <code>Matrix</code> <p>KCL equations for the system.</p> <code>G</code> <code>ndarray</code> <p>G-matrix representing the connections between modules.</p> <code>StateVariableDerivatives</code> <code>Matrix</code> <p>Derivatives of the state variables.</p> <code>StateSpaceEquations</code> <code>Matrix</code> <p>State space equations for the system.</p> <code>DesiredStateVariableDerivatives</code> <code>Matrix</code> <p>Desired derivatives of the state variables.</p> <code>DesiredStateSpace</code> <code>Matrix</code> <p>Desired state space equations.</p> <code>ControllableInputs</code> <code>Matrix</code> <p>Inputs that can be controlled.</p> <code>InternalInputs</code> <code>Matrix</code> <p>Internal inputs to the system.</p> <code>ControlInputEquations</code> <code>Matrix</code> <p>Equations for control inputs.</p> <code>SetPointOutputs</code> <code>Matrix</code> <p>Outputs for set points.</p> <code>SetPointOutputEquations</code> <code>Matrix</code> <p>Equations for set point outputs.</p> <code>StateVariables</code> <code>Matrix</code> <p>State variables of the system.</p> <code>DesiredStateVariables</code> <code>Matrix</code> <p>Desired state variables.</p> <code>InternalEquations</code> <code>Matrix</code> <p>Internal equations of the system.</p> <code>Parameters</code> <code>Matrix</code> <p>Parameters of the system.</p> <code>SetPoints</code> <code>Matrix</code> <p>Set points for the system.</p> <code>ControllerGains</code> <code>Matrix</code> <p>Gains for the controllers.</p>"},{"location":"simulation/#pycamps.simulation.Dynamics","title":"<code>pycamps.simulation.Dynamics</code>","text":"<p>Simulates the dynamics of a power system.</p> <p>Parameters:</p> Name Type Description Default <code>power_system</code> <code>PowerSystem</code> <p>The power system object containing modules and buses.</p> required <p>Attributes:</p> Name Type Description <code>PS</code> <code>PowerSystem</code> <p>The power system object.</p> <code>params</code> <code>dict</code> <p>A dictionary of parameters for the modules.</p> <code>input_states</code> <code>list</code> <p>A list of input state variables.</p> <code>input_equations</code> <code>list</code> <p>A list of input equations.</p> <code>required_params</code> <code>dict</code> <p>A dictionary mapping module names to their required parameters.</p>"},{"location":"simulation/#pycamps.simulation.Dynamics.get_required_parameters","title":"<code>get_required_parameters()</code>","text":"<p>Create a mapping of each module to the parameters required by that module.</p> <p>Returns:</p> Name Type Description <code>required_params</code> <code>dict</code> <p>A dictionary mapping module names to their required parameters.</p>"},{"location":"simulation/#pycamps.simulation.Dynamics.linearized_analysis","title":"<code>linearized_analysis(xf=None)</code>","text":"<p>Given the system dynamics, perform a linearized analysis of the system.</p> <p>Parameters:</p> Name Type Description Default <code>xf</code> <code>Optional[ndarray]</code> <p>Final state values for the linearized analysis, defaults to a random uniform NumPy array.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pf</code> <code>Optional[ndarray]</code> <p>Participation factors of states contributing to instability.</p> <code>states</code> <code>Optional[ndarray]</code> <p>Names of states contributing to instability.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If xf has the wrong length.</p>"},{"location":"simulation/#pycamps.simulation.Dynamics.load_new_params","title":"<code>load_new_params(params_directory=None, custom_module_files=None, params_dictionary=None, reference_frame={sp.Symbol('dphidt', real=True): 1, sp.Symbol('phi', real=True): 0})</code>","text":"<p>Loads new parameters from a directory, custom mapping, or a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>params_directory</code> <code>Optional[str]</code> <p>The path to the directory containing parameter files. Files should be named 'module_name.mat' or 'module_name.json'.</p> <code>None</code> <code>custom_module_files</code> <code>Optional[dict]</code> <p>A dictionary mapping module names to custom parameter files. File paths should be full paths.</p> <code>None</code> <code>params_dictionary</code> <code>Optional[dict]</code> <p>A dictionary containing parameters. Keys should be parameter names in the form of '{parameter_name}_{module_name}'.</p> <code>None</code> <code>reference_frame</code> <code>Optional[dict]</code> <p>A dictionary specifying the reference frame.</p> <code>{Symbol('dphidt', real=True): 1, Symbol('phi', real=True): 0}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a required parameter is missing or if the number of states and equations do not match.</p>"},{"location":"simulation/#pycamps.simulation.Dynamics.save_dynamics","title":"<code>save_dynamics(file_path=None)</code>","text":"<p>Saves the dynamics object to a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Optional[str]</code> <p>The path to the file where the dynamics object will be saved.</p> <code>None</code>"},{"location":"simulation/#pycamps.simulation.Dynamics.simulate_trajectory","title":"<code>simulate_trajectory(xf=None, simulation_time=0.1, method='trapezoid_adaptive')</code>","text":"<p>Given the system dynamics, simulate the trajectory of the system. Supported methods are 'trapezoid_adaptive', 'LSODA', 'RK45', 'RK23', 'DOP853', 'Radau', 'BDF'</p> <p>Parameters:</p> Name Type Description Default <code>xf</code> <code>Optional[ndarray]</code> <p>Final state values, defaults to a random uniform NumPy array.</p> <code>None</code> <code>simulation_time</code> <code>float</code> <p>The duration of the simulation.</p> <code>0.1</code> <code>method</code> <code>str</code> <p>The method to use for simulating the trajectory.</p> <code>'trapezoid_adaptive'</code> <p>Returns:</p> Name Type Description <code>time</code> <code>ndarray</code> <p>The time values of the simulation.</p> <code>states</code> <code>dict</code> <p>A dictionary of state values over time.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If xf has the wrong length.</p>"},{"location":"simulation/#pycamps.simulation.Dynamics.solve_equilibrium","title":"<code>solve_equilibrium(x0=None, options=None, method='fsolve')</code>","text":"<p>Given the system dynamics, solve for the equilibrium values of the system. Supported methods are 'fsolve', 'hybr', 'lm', 'broyden1', 'broyden2', 'anderson',   'linearmixing', 'diagbroyden', 'excitingmixing', 'krylov', 'df-sane'</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>Optional[ndarray]</code> <p>Initial guess for the equilibrium values, defaults to a random uniform NumPy array.</p> <code>None</code> <code>options</code> <code>Optional[dict]</code> <p>Options for the solver.</p> <code>None</code> <code>method</code> <code>str</code> <p>The method to use for solving the equilibrium. </p> <code>'fsolve'</code> <p>Returns:</p> Name Type Description <code>xf</code> <code>ndarray</code> <p>The equilibrium values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the equilibrium is not found or if x0 has the wrong length.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace","title":"<code>pycamps.simulation.StateSpace</code>","text":"<p>Represents a state space model for a power system or module.</p> <p>Parameters:</p> Name Type Description Default <code>system_name</code> <code>str</code> <p>The name of the system.</p> required <code>set_point_outputs</code> <code>Matrix</code> <p>A SymPy matrix of set point outputs.</p> required <code>set_point_output_equations</code> <code>Matrix</code> <p>A SymPy matrix of equations for set point outputs.</p> required <code>controllable_inputs</code> <code>Matrix</code> <p>A SymPy matrix of controllable inputs.</p> required <code>control_input_equations</code> <code>Matrix</code> <p>A SymPy matrix of equations for controllable inputs.</p> required <code>internal_inputs</code> <code>Matrix</code> <p>A SymPy matrix of internal inputs.</p> required <code>internal_equations</code> <code>Matrix</code> <p>A SymPy matrix of internal equations.</p> required <code>state_variable_derivatives</code> <code>Matrix</code> <p>A SymPy matrix of state variable derivatives.</p> required <code>state_space_equations</code> <code>Matrix</code> <p>A SymPy matrix of state space equations.</p> required <code>desired_state_variable_derivatives</code> <code>Matrix</code> <p>A SymPy matrix of desired state variable derivatives.</p> required <code>desired_state_space</code> <code>Matrix</code> <p>A SymPy matrix of desired state space equations.</p> required <code>state_variables</code> <code>Matrix</code> <p>A SymPy matrix of state variables.</p> required <code>desired_state_variables</code> <code>Matrix</code> <p>A SymPy matrix of desired state variables.</p> required <code>units</code> <code>list of str</code> <p>A list of units for the state variables.</p> required"},{"location":"simulation/#pycamps.simulation.StateSpace.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Checks if two StateSpace instances are equal.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the StateSpace instance.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.from_module","title":"<code>from_module(module)</code>  <code>classmethod</code>","text":"<p>Creates a StateSpace instance from a Module instance.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.from_power_system","title":"<code>from_power_system(PS)</code>  <code>classmethod</code>","text":"<p>Creates a StateSpace instance from a PowerSystem instance.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.print_equations","title":"<code>print_equations()</code>","text":"<p>Prints out the interconnected state space equations to the log stream.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.print_vector_x","title":"<code>print_vector_x()</code>","text":"<p>Prints out the interconnected state space equations (dx) in a form suitable for  running the simulation directly. Also assigns value of each element of the  vector (x) into the respective state variables.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.write_equations","title":"<code>write_equations(filename=None)</code>","text":"<p>Writes out the interconnected state space equations to a file.</p>"},{"location":"simulation/#pycamps.simulation.StateSpace.write_vector_x","title":"<code>write_vector_x(filename=None)</code>","text":"<p>Writes the interconnected state space equations (dx) into a file in a form  suitable for running the simulation directly. Also assigns value of each element  of the vector (x) into the respective state variables.</p>"},{"location":"examples/pycamps_intro/","title":"Intro to PyCAMPS","text":"In\u00a0[3]: Copied! <pre>!pip install pycamps==0.0.9\n!pip install plotly\n</pre> !pip install pycamps==0.0.9 !pip install plotly <pre>Collecting pycamps==0.0.9\n  Downloading pycamps-0.0.9-py3-none-any.whl.metadata (1.4 kB)\nRequirement already satisfied: matplotlib in /usr/local/lib/python3.10/dist-packages (from pycamps==0.0.9) (3.7.1)\nRequirement already satisfied: mpmath in /usr/local/lib/python3.10/dist-packages (from pycamps==0.0.9) (1.3.0)\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (from pycamps==0.0.9) (1.26.4)\nRequirement already satisfied: pytest in /usr/local/lib/python3.10/dist-packages (from pycamps==0.0.9) (7.4.4)\nRequirement already satisfied: scipy in /usr/local/lib/python3.10/dist-packages (from pycamps==0.0.9) (1.13.1)\nRequirement already satisfied: sympy in /usr/local/lib/python3.10/dist-packages (from pycamps==0.0.9) (1.13.2)\nRequirement already satisfied: contourpy&gt;=1.0.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (1.3.0)\nRequirement already satisfied: cycler&gt;=0.10 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (0.12.1)\nRequirement already satisfied: fonttools&gt;=4.22.0 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (4.53.1)\nRequirement already satisfied: kiwisolver&gt;=1.0.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (1.4.7)\nRequirement already satisfied: packaging&gt;=20.0 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (24.1)\nRequirement already satisfied: pillow&gt;=6.2.0 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (9.4.0)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (3.1.4)\nRequirement already satisfied: python-dateutil&gt;=2.7 in /usr/local/lib/python3.10/dist-packages (from matplotlib-&gt;pycamps==0.0.9) (2.8.2)\nRequirement already satisfied: iniconfig in /usr/local/lib/python3.10/dist-packages (from pytest-&gt;pycamps==0.0.9) (2.0.0)\nRequirement already satisfied: pluggy&lt;2.0,&gt;=0.12 in /usr/local/lib/python3.10/dist-packages (from pytest-&gt;pycamps==0.0.9) (1.5.0)\nRequirement already satisfied: exceptiongroup&gt;=1.0.0rc8 in /usr/local/lib/python3.10/dist-packages (from pytest-&gt;pycamps==0.0.9) (1.2.2)\nRequirement already satisfied: tomli&gt;=1.0.0 in /usr/local/lib/python3.10/dist-packages (from pytest-&gt;pycamps==0.0.9) (2.0.1)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.10/dist-packages (from python-dateutil&gt;=2.7-&gt;matplotlib-&gt;pycamps==0.0.9) (1.16.0)\nDownloading pycamps-0.0.9-py3-none-any.whl (82 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 82.1/82.1 kB 1.8 MB/s eta 0:00:00\nInstalling collected packages: pycamps\n  Attempting uninstall: pycamps\n    Found existing installation: PyCAMPS 0.0.8\n    Uninstalling PyCAMPS-0.0.8:\n      Successfully uninstalled PyCAMPS-0.0.8\nSuccessfully installed pycamps-0.0.9\nRequirement already satisfied: plotly in /usr/local/lib/python3.10/dist-packages (5.15.0)\nRequirement already satisfied: tenacity&gt;=6.2.0 in /usr/local/lib/python3.10/dist-packages (from plotly) (9.0.0)\nRequirement already satisfied: packaging in /usr/local/lib/python3.10/dist-packages (from plotly) (24.1)\n</pre> In\u00a0[4]: Copied! <pre>from pycamps.modules import Type4_1, RLLoad, LongLine\nfrom pycamps.simulation import Dynamics, PowerSystem, StateSpace\nfrom pycamps.logger import configure_logging\nfrom sympy import symbols, pprint\nfrom sympy import latex, init_printing\ninit_printing(use_latex='mathjax')\nfrom IPython.display import display, Math\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport os\nos.environ['LOG_LEVEL'] = 'INFO'\nlogger = configure_logging(log_to_console=True, log_to_file=False)\n</pre> from pycamps.modules import Type4_1, RLLoad, LongLine from pycamps.simulation import Dynamics, PowerSystem, StateSpace from pycamps.logger import configure_logging from sympy import symbols, pprint from sympy import latex, init_printing init_printing(use_latex='mathjax') from IPython.display import display, Math import plotly.graph_objects as go from plotly.subplots import make_subplots  import os os.environ['LOG_LEVEL'] = 'INFO' logger = configure_logging(log_to_console=True, log_to_file=False) In\u00a0[5]: Copied! <pre>def display_equations(M):\n  for i, equation in enumerate(M):\n    latex_equations = latex(equation, mul_symbol='dot').replace('{eq}\\'', '{{eq}^{\\prime}}')\n    latex_equations = latex_equations.replace('{xd}\\'', '{{xd}^{\\prime}}')\n    latex_equations = latex_equations.replace('dphidt', '\\\\frac{d \\phi}{dt}')\n    latex_equations = r\"\\textbf{(\" + str(i+1) + r\")} \\quad \" + latex_equations\n    display(Math(latex_equations))\n\ndef display_matrix(M):\n  latex_equations = latex(M, mul_symbol='dot').replace('{eq}\\'', '{{eq}^{\\prime}}')\n  latex_equations = latex_equations.replace('{xd}\\'', '{{xd}^{\\prime}}')\n  latex_equations = latex_equations.replace('dphidt', '\\\\frac{d \\phi}{dt}')\n  display(Math(latex_equations))\n</pre> def display_equations(M):   for i, equation in enumerate(M):     latex_equations = latex(equation, mul_symbol='dot').replace('{eq}\\'', '{{eq}^{\\prime}}')     latex_equations = latex_equations.replace('{xd}\\'', '{{xd}^{\\prime}}')     latex_equations = latex_equations.replace('dphidt', '\\\\frac{d \\phi}{dt}')     latex_equations = r\"\\textbf{(\" + str(i+1) + r\")} \\quad \" + latex_equations     display(Math(latex_equations))  def display_matrix(M):   latex_equations = latex(M, mul_symbol='dot').replace('{eq}\\'', '{{eq}^{\\prime}}')   latex_equations = latex_equations.replace('{xd}\\'', '{{xd}^{\\prime}}')   latex_equations = latex_equations.replace('dphidt', '\\\\frac{d \\phi}{dt}')   display(Math(latex_equations)) In\u00a0[6]: Copied! <pre>import plotly.io as pio\npio.renderers.default = \"colab\"\n\nimport plotly.graph_objects as go\n\ndef plot_trajectory(time, states):\n    fig = go.Figure()\n    n = max(1, len(time) // 1000)\n\n    # Create traces for each state\n    for variable_name, array in states.items():\n        fig.add_trace(go.Scatter(x=time[::n], y=array[::n], name=variable_name, visible=True))\n\n    buttons = [ dict(\n                    label='All',\n                    method=\"update\",\n                    args=[{\"visible\": [True]*len(states)},\n                          {\"title\": 'All'}]\n                )\n              ]\n    # Create updatemenus (checkboxes)\n    updatemenus = [\n        dict(\n            type=\"dropdown\",\n            direction=\"down\",\n            active=0,\n            x=1.02,\n            y=1,\n            yanchor=\"top\",\n            buttons=buttons + [\n                dict(\n                    label=variable_name,\n                    method=\"update\",\n                    args=[{\"visible\": [var == variable_name for var in states.keys()]},\n                          {\"title\": variable_name}]\n                ) for variable_name in states.keys()\n            ],\n        )\n    ]\n\n    # Update layout\n    fig.update_layout(\n        updatemenus=updatemenus,\n        showlegend=True,\n        legend=dict(x=1.02, y=0.5),\n        margin=dict(r=200),  # Add right margin for the menu\n        width=1000,  # Increase overall width\n        height=600,  # Set a reasonable height\n    )\n\n    # Add a rangeslider\n    fig.update_xaxes(rangeslider_visible=True)\n\n    # Show the plot\n    fig.show()\n</pre> import plotly.io as pio pio.renderers.default = \"colab\"  import plotly.graph_objects as go  def plot_trajectory(time, states):     fig = go.Figure()     n = max(1, len(time) // 1000)      # Create traces for each state     for variable_name, array in states.items():         fig.add_trace(go.Scatter(x=time[::n], y=array[::n], name=variable_name, visible=True))      buttons = [ dict(                     label='All',                     method=\"update\",                     args=[{\"visible\": [True]*len(states)},                           {\"title\": 'All'}]                 )               ]     # Create updatemenus (checkboxes)     updatemenus = [         dict(             type=\"dropdown\",             direction=\"down\",             active=0,             x=1.02,             y=1,             yanchor=\"top\",             buttons=buttons + [                 dict(                     label=variable_name,                     method=\"update\",                     args=[{\"visible\": [var == variable_name for var in states.keys()]},                           {\"title\": variable_name}]                 ) for variable_name in states.keys()             ],         )     ]      # Update layout     fig.update_layout(         updatemenus=updatemenus,         showlegend=True,         legend=dict(x=1.02, y=0.5),         margin=dict(r=200),  # Add right margin for the menu         width=1000,  # Increase overall width         height=600,  # Set a reasonable height     )      # Add a rangeslider     fig.update_xaxes(rangeslider_visible=True)      # Show the plot     fig.show() <p>We're going to go through a simple example of setting up a power system and running some simulations.</p> <p>Let's initialize some components of our power system. For this example, our synchronous machine will be a Type 4-1 Generator connected to a standard RL load.</p> In\u00a0[7]: Copied! <pre>SM = Type4_1('G1', BaseSpeed=377)\nTL = LongLine('TL_1_2', BaseSpeed=377)\nL = RLLoad('L1', BaseSpeed=377)\nModules = [SM, TL, L]\n</pre> SM = Type4_1('G1', BaseSpeed=377) TL = LongLine('TL_1_2', BaseSpeed=377) L = RLLoad('L1', BaseSpeed=377) Modules = [SM, TL, L] <p>Let's take a look at our components' state space equations to verify they're correct.</p> In\u00a0[8]: Copied! <pre>display_equations(SM.StateSpaceEquations)\n</pre> display_equations(SM.StateSpaceEquations)  $\\displaystyle \\textbf{(1)} \\quad - 377 \\cdot \\frac{d \\phi}{dt} + 377 \\cdot \\omega_{G1}$   $\\displaystyle \\textbf{(2)} \\quad \\frac{377 \\cdot \\left({{eq}^{\\prime}}_{G1} \\cdot \\left(RS_{G1} \\cdot {{eq}^{\\prime}}_{G1} \\cdot \\cos{\\left(2 \\cdot \\delta_{G1} \\right)} - RS_{G1} \\cdot vSd_{G1} \\cdot \\cos{\\left(\\delta_{G1} \\right)} + RS_{G1} \\cdot vSq_{G1} \\cdot \\sin{\\left(\\delta_{G1} \\right)} + {{eq}^{\\prime}}_{G1} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\sin{\\left(2 \\cdot \\delta_{G1} \\right)} - vSd_{G1} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\sin{\\left(\\delta_{G1} \\right)} - vSq_{G1} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\cos{\\left(\\delta_{G1} \\right)}\\right) + \\left(RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}\\right) \\cdot \\left(D_{G1} \\cdot \\left(\\frac{d \\phi}{dt} - \\omega_{G1}\\right) + Pm_{G1}\\right)\\right)}{J_{G1} \\cdot \\left(RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}\\right)}$  In\u00a0[9]: Copied! <pre>display_equations(TL.StateSpaceEquations)\n</pre> display_equations(TL.StateSpaceEquations)  $\\displaystyle \\textbf{(1)} \\quad \\frac{377 \\cdot \\left(CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLLq_{TL 1 2} + iInLd_{TL 1 2} - iTLMd_{TL 1 2}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(2)} \\quad \\frac{377 \\cdot \\left(- CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLLd_{TL 1 2} + iInLq_{TL 1 2} - iTLMq_{TL 1 2}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(3)} \\quad \\frac{377 \\cdot \\left(LTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot iTLMq_{TL 1 2} - RTL_{TL 1 2} \\cdot iTLMd_{TL 1 2} + vTLLd_{TL 1 2} - vTLRd_{TL 1 2}\\right)}{LTL_{TL 1 2}}$   $\\displaystyle \\textbf{(4)} \\quad \\frac{377 \\cdot \\left(- LTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot iTLMd_{TL 1 2} - RTL_{TL 1 2} \\cdot iTLMq_{TL 1 2} + vTLLq_{TL 1 2} - vTLRq_{TL 1 2}\\right)}{LTL_{TL 1 2}}$   $\\displaystyle \\textbf{(5)} \\quad \\frac{377 \\cdot \\left(CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLRq_{TL 1 2} + iInRd_{TL 1 2} + iTLMd_{TL 1 2}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(6)} \\quad \\frac{377 \\cdot \\left(- CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLRd_{TL 1 2} + iInRq_{TL 1 2} + iTLMq_{TL 1 2}\\right)}{CTL_{TL 1 2}}$  In\u00a0[10]: Copied! <pre>display_equations(L.StateSpaceEquations)\n</pre> display_equations(L.StateSpaceEquations)  $\\displaystyle \\textbf{(1)} \\quad \\frac{377 \\cdot \\left(LL_{L1} \\cdot \\frac{d \\phi}{dt} \\cdot iLq_{L1} - RL_{L1} \\cdot iLd_{L1} + vLd_{L1}\\right)}{LL_{L1}}$   $\\displaystyle \\textbf{(2)} \\quad \\frac{377 \\cdot \\left(- LL_{L1} \\cdot \\frac{d \\phi}{dt} \\cdot iLd_{L1} - RL_{L1} \\cdot iLq_{L1} + vLq_{L1}\\right)}{LL_{L1}}$  <p>Now let's connect our components together via buses and initialize a PowerSystem object.</p> In\u00a0[11]: Copied! <pre>Bus1 = [[SM], [TL,'L']]\nBus2 = [[L], [TL,'R']]\nBuses = [Bus1, Bus2]\n\n# Initialize power system\nPS = PowerSystem(\"Example_1\", Modules, Buses)\n</pre> Bus1 = [[SM], [TL,'L']] Bus2 = [[L], [TL,'R']] Buses = [Bus1, Bus2]  # Initialize power system PS = PowerSystem(\"Example_1\", Modules, Buses) <pre>INFO - Produced G-matrix:\n[[1. 0. 1. 0. 0. 0. 0. 0.]\n [0. 1. 0. 1. 0. 0. 0. 0.]\n [0. 0. 0. 0. 1. 0. 1. 0.]\n [0. 0. 0. 0. 0. 1. 0. 1.]]\nINFO - The KCL constraints between modules are:\n-------------------------\n1.0*iInLd_TL_1_2 - 1.0*(RS_G1*eqprime_G1*cos(delta_G1) - RS_G1*vSd_G1 + eqprime_G1*xdprime_G1*sin(delta_G1) - vSq_G1*xdprime_G1)/(RS_G1**2 + xdprime_G1**2) = 0\n1.0*iInLq_TL_1_2 - 1.0*(RS_G1*eqprime_G1*sin(delta_G1) - RS_G1*vSq_G1 - eqprime_G1*xdprime_G1*cos(delta_G1) + vSd_G1*xdprime_G1)/(RS_G1**2 + xdprime_G1**2) = 0\n1.0*iInRd_TL_1_2 + 1.0*iLd_L1 = 0\n1.0*iInRq_TL_1_2 + 1.0*iLq_L1 = 0\n-------------------------\nINFO - Produced state space for Example_1\n</pre> <p>Congratulations, you've made your first power system! Let's take a look at its state space.</p> In\u00a0[12]: Copied! <pre>display_equations(PS.StateSpaceEquations)\n</pre> display_equations(PS.StateSpaceEquations)  $\\displaystyle \\textbf{(1)} \\quad - 377 \\cdot \\frac{d \\phi}{dt} + 377 \\cdot \\omega_{G1}$   $\\displaystyle \\textbf{(2)} \\quad \\frac{377 \\cdot \\left({{eq}^{\\prime}}_{G1} \\cdot \\left(RS_{G1} \\cdot {{eq}^{\\prime}}_{G1} \\cdot \\cos{\\left(2 \\cdot \\delta_{G1} \\right)} - RS_{G1} \\cdot vTLLd_{TL 1 2} \\cdot \\cos{\\left(\\delta_{G1} \\right)} + RS_{G1} \\cdot vTLLq_{TL 1 2} \\cdot \\sin{\\left(\\delta_{G1} \\right)} + {{eq}^{\\prime}}_{G1} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\sin{\\left(2 \\cdot \\delta_{G1} \\right)} - vTLLd_{TL 1 2} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\sin{\\left(\\delta_{G1} \\right)} - vTLLq_{TL 1 2} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\cos{\\left(\\delta_{G1} \\right)}\\right) + \\left(RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}\\right) \\cdot \\left(D_{G1} \\cdot \\left(\\frac{d \\phi}{dt} - \\omega_{G1}\\right) + Pm_{G1}\\right)\\right)}{J_{G1} \\cdot \\left(RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}\\right)}$   $\\displaystyle \\textbf{(3)} \\quad \\frac{377 \\cdot \\left(CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLLq_{TL 1 2} + \\frac{RS_{G1} \\cdot {{eq}^{\\prime}}_{G1} \\cdot \\cos{\\left(\\delta_{G1} \\right)}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}} - \\frac{RS_{G1} \\cdot vTLLd_{TL 1 2}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}} + \\frac{{{eq}^{\\prime}}_{G1} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\sin{\\left(\\delta_{G1} \\right)}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}} - iTLMd_{TL 1 2} - \\frac{vTLLq_{TL 1 2} \\cdot {{xd}^{\\prime}}_{G1}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(4)} \\quad \\frac{377 \\cdot \\left(- CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLLd_{TL 1 2} + \\frac{RS_{G1} \\cdot {{eq}^{\\prime}}_{G1} \\cdot \\sin{\\left(\\delta_{G1} \\right)}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}} - \\frac{RS_{G1} \\cdot vTLLq_{TL 1 2}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}} - \\frac{{{eq}^{\\prime}}_{G1} \\cdot {{xd}^{\\prime}}_{G1} \\cdot \\cos{\\left(\\delta_{G1} \\right)}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}} - iTLMq_{TL 1 2} + \\frac{vTLLd_{TL 1 2} \\cdot {{xd}^{\\prime}}_{G1}}{RS_{G1}^{2} + {{xd}^{\\prime}}_{G1}^{2}}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(5)} \\quad \\frac{377 \\cdot \\left(LTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot iTLMq_{TL 1 2} - RTL_{TL 1 2} \\cdot iTLMd_{TL 1 2} + vTLLd_{TL 1 2} - vTLRd_{TL 1 2}\\right)}{LTL_{TL 1 2}}$   $\\displaystyle \\textbf{(6)} \\quad \\frac{377 \\cdot \\left(- LTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot iTLMd_{TL 1 2} - RTL_{TL 1 2} \\cdot iTLMq_{TL 1 2} + vTLLq_{TL 1 2} - vTLRq_{TL 1 2}\\right)}{LTL_{TL 1 2}}$   $\\displaystyle \\textbf{(7)} \\quad \\frac{377 \\cdot \\left(CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLRq_{TL 1 2} - iLd_{L1} + iTLMd_{TL 1 2}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(8)} \\quad \\frac{377 \\cdot \\left(- CTL_{TL 1 2} \\cdot \\frac{d \\phi}{dt} \\cdot vTLRd_{TL 1 2} - iLq_{L1} + iTLMq_{TL 1 2}\\right)}{CTL_{TL 1 2}}$   $\\displaystyle \\textbf{(9)} \\quad \\frac{377 \\cdot \\left(LL_{L1} \\cdot \\frac{d \\phi}{dt} \\cdot iLq_{L1} - RL_{L1} \\cdot iLd_{L1} + vTLRd_{TL 1 2}\\right)}{LL_{L1}}$   $\\displaystyle \\textbf{(10)} \\quad \\frac{377 \\cdot \\left(- LL_{L1} \\cdot \\frac{d \\phi}{dt} \\cdot iLd_{L1} - RL_{L1} \\cdot iLq_{L1} + vTLRq_{TL 1 2}\\right)}{LL_{L1}}$  <p>Alright, we've set up our power system and verified the state space equations, so let's start solving for equilibrium! Let's instantiate a Dynamics object and find out which component parameters we need to plug in.</p> In\u00a0[13]: Copied! <pre>simulator = Dynamics(PS)\nsimulator.get_required_parameters()\n</pre> simulator = Dynamics(PS) simulator.get_required_parameters() Out[13]: <pre>{'G1': [J_G1, D_G1, xdprime_G1, RS_G1, eqprime_G1, Pm_G1],\n 'TL_1_2': [RTL_TL_1_2, CTL_TL_1_2, LTL_TL_1_2],\n 'L1': [RL_L1, LL_L1]}</pre> <p>For this example, we've provided you with the required parameters for our components.</p> In\u00a0[14]: Copied! <pre>params_dictionary = {'J_G1': 76531.33492530156,\n                     'D_G1': 1,\n                     'xdprime_G1': 0.005,\n                     'RS_G1': 0.0001,\n                     'eqprime_G1': -1.35,\n                     'Pm_G1': 1.4786690000000817,\n                     'RTL_TL_1_2': 0.02978336677167938,\n                     'CTL_TL_1_2': 0.001,\n                     'LTL_TL_1_2': 0.40681749584779936,\n                     'RL_L1': 2.3125,\n                     'LL_L1': 0.9588}\n</pre> params_dictionary = {'J_G1': 76531.33492530156,                      'D_G1': 1,                      'xdprime_G1': 0.005,                      'RS_G1': 0.0001,                      'eqprime_G1': -1.35,                      'Pm_G1': 1.4786690000000817,                      'RTL_TL_1_2': 0.02978336677167938,                      'CTL_TL_1_2': 0.001,                      'LTL_TL_1_2': 0.40681749584779936,                      'RL_L1': 2.3125,                      'LL_L1': 0.9588} In\u00a0[15]: Copied! <pre>simulator.load_new_params(params_dictionary=params_dictionary)\nxf = simulator.solve_equilibrium(method='hybr')\n</pre> simulator.load_new_params(params_dictionary=params_dictionary) xf = simulator.solve_equilibrium(method='hybr') <pre>INFO - Solving for equilibrium values of Example_1\nINFO - Equilibrium values:\n-------------------------\ndelta_G1: 1.7240938868791578\nomega_G1: 0.9999999763315144\nvTLLd_TL_1_2: 0.20384754416483242\nvTLLq_TL_1_2: -1.333223658211601\niTLMd_TL_1_2: -0.181576837552206\niTLMq_TL_1_2: -0.46280328107422397\nvTLRd_TL_1_2: 0.020979052457981817\nvTLRq_TL_1_2: -1.2455712151093845\niLd_L1: -0.1828224021007726\niLq_L1: -0.4628242287792925\n-------------------------\nINFO - Saved equilibrium values to results/equilibrium/Example_1_Solved.mat\n</pre> <p>Great! You should see a set of equilibrium values for the state variables of the power system. Let's now analyze the stability of our system using linearized analysis.</p> In\u00a0[16]: Copied! <pre>simulator.linearized_analysis(xf=xf)\n</pre> simulator.linearized_analysis(xf=xf) <pre>INFO - Performing linearized analysis of Example_1\nINFO - No unstable eigenvalues\n</pre> Out[16]: <pre>(None, None)</pre> <p>Now we can simulate the trajectory of the power system over a set time period and see how the state changes over time.</p> In\u00a0[17]: Copied! <pre>time, states = simulator.simulate_trajectory(xf=xf, simulation_time=0.3, method='LSODA')\nplot_trajectory(time, states)\n</pre> time, states = simulator.simulate_trajectory(xf=xf, simulation_time=0.3, method='LSODA') plot_trajectory(time, states) <pre>INFO - Simulating trajectory of Example_1\nINFO - Ending simulation at t = 0.3\nINFO - Saved trajectory values to results/trajectory/Example_1_Simulation.mat\n</pre> <p>Try messing around with the starting values and seeing how the system reacts when xf is not at equilibrium.</p> <p>Hint: Multiply xf by some constant value like 1.1 and run the previous cell again.</p>"},{"location":"examples/pycamps_intro/#intro-to-pycamps","title":"Intro to PyCAMPS\u00b6","text":"<p>The Centralized Automated Modeling of Power Systems library in Python (PyCAMPS) is a library that allows users to easily set up power systems, analyze stability, and run simulations. This notebook will go through a simple example and walk you through the different functions you can use.</p>"},{"location":"examples/pycamps_intro/#boilerplate","title":"Boilerplate\u00b6","text":""},{"location":"examples/pycamps_intro/#setting-up-the-power-system","title":"Setting up the power system\u00b6","text":""},{"location":"examples/pycamps_intro/#examining-the-dynamics","title":"Examining the dynamics\u00b6","text":""}]}